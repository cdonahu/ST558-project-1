---
title: "COVID-19 API Vignette"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# My First Vignette  

This document is a vignette to describe how to read and summarize data from an API. I will demonstrate using a [COVID-19 API]{https://covid19api.com/}, because my attempts to work with the Pokemon API were unsuccessful. I will build a couple of functions to interact and explore the data we can retrieve from the API.   

To use a function that returns data at the country level, the user may either enter the country's name or its two-letter country code in the [ISO 3166]{https://www.iban.com/country-codes} format. 

## Requirements

I used the following packages in the creation of the vignette, and the user will need them to run the functions and interact with the COVID-19 API:  

- [`httr`]{https://httr.r-lib.org/}: I used this to access the API  
- [`jsonlite`]{https://cran.r-project.org/web/packages/jsonlite/index.html}: I used this to convert the Pokemon data to a dataframe    
- [`tidyverse`]{https://www.tidyverse.org/}: I used this set of packages for things like piping and plotting data visualizations  


To get started, install and load the packages listed above: 

```{r Install and Read in Packages, message=FALSE}
library(httr)
library(jsonlite)
library(tidyverse)
```


## Functions to Interact With the API

The COVID-19 API is simple because it does not require users to get a key and authenticate. This makes accessing it less complex than some other APIs. If you want, you can purchase different monthly subscription levels for more than just the basic authorization to the API. The premium subscriptions include more interesting data (population ages, GDP, diabetes rates, handwashing facilities, etc.) and no rate limit.  

### `countryCases`

I wrote a function `countryCases` for a user to interact with the `summary` endpoint of the Coronavirus COVID19 API. It returns a data frame with key metrics (cases, deaths, recoveries) for every country. It accepts one argument, `country`, and the default value is "all". The user may enter a country's name or its two character country code to get only data for a specific country.  


```{r countryCases function}
countryCases <- function(country="all"){
  ###
  # This function returns a data frame with data on Covid cases. It can also
  # return those columns for a single country if a country's name or abbreviation is passed.
  ###
  
  # Get the country data from the summaryRoute endpoint.
  outputAPI <- fromJSON(
    "https://api.covid19api.com/summary"
  )
  
  # Select only the Countries data from the JSON output.
  output <- outputAPI$Countries
  
  # If country does not equal "all", check if it is an abbrev or country name.
  if (country != "all"){
    
    # If country is in the CountryCode column, subset output for just that row.
    if (country %in% output$CountryCode){
      output <- output %>%
        filter(CountryCode == country)
    }
    # If country is in the Country column, subset output for just that row.
    else if (country %in% output$Country){
      output <- output %>%
        filter(Country == country)
    }
    # Otherwise, throw an informative error.
    else {
      message <- paste("ERROR: Argument for country was not found in either",
                       "the Country or CountryCode columns. Try ('all') to",
                       "find the country you're looking for.")
      stop(message)
    }
  }
  # Do nothing if the country value equals "all".
  else {
    
  }
  
 # Return the output data frame.
  return(output)
}
```

### `getSlug`  

I also wrote a helper function, `getSlug`, which finds the "slug", or the version of a country's name formatted for use within a URL. It uses the `Countries` endpoint. The user inputs a country's name or two-letter abbreviation, and `getSlug` returns the slug. This will help in other functions that interact with the COVID-19 API.  

```{r getSlug function}
# Function to get the slug for a given country name or abbreviation
getSlug <- function(country){
  
  # Get the country list from the Countries endpoint.
  output <- fromJSON("https://api.covid19api.com/countries")
  
  # If country is in the ISO2 column, subset output for just that row.
  if (country %in% output$ISO2){
    output <- output$Slug[output$ISO2 == country]
  }
  # If country is in the Country column, subset output for just that row.
  else if (country %in% output$Country){
    output <- output$Slug[output$Country == country]
  }
  # Otherwise, throw an informative error.
  else {
    message <- paste("ERROR: Argument for country was not found in either",
                     "the Country or CountryCode columns. Try ('all') to",
                     "find the country you're looking for.")
    stop(message)
  }
  # Return the slug.
  return(output)
}
```


### `dailyCases`  

I wrote a function to allow the user to select a country of interest and receive the daily confirmed case count for that country, as well as the country's location (latitude/longitude). The `dailyCases` function uses the helper function `getSlug` from above to retrieve the information via the `Day One Live` endpoint. It returns cumulative confirmed cases starting with the first day a case was confirmed.   

```{r dailyCases function}
dailyCases <- function(country){
  ###
  # This function returns a data frame with data on number of confirmed Covid cases on each date in a user-selected country. 
  ###
  
  # find the "slug" based on the country the user selected
  slug <- getSlug(country)
  
  # Get the country data from the Day One Live endpoint.
  output <- fromJSON(paste(
    "https://api.covid19api.com/dayone/country/", slug, "/status/confirmed/live", sep = "")
  )
  
  # If country is in the CountryCode column, subset output for just that row.
  if (country %in% output$CountryCode){
    output <- output %>%
      filter(CountryCode == country)
  }
  # If country is in the Country column, subset output for just that row.
  else if (country %in% output$Country){
    output <- output %>%
      filter(Country == country)
  }
  # Otherwise, throw an informative error.
  else {
    message <- paste("ERROR: Argument for country was not found in either",
                       "the Country or CountryCode columns. Try ('all') to",
                       "find the country you're looking for.")
    stop(message)
  }

  # Return the output data frame.
  return(output)
}
```


### `plotCases`

Next, I wanted to create a function to plot the cases by date, so the user could get a visualization of the type of data they retrieve using my `dailyCases` function. The user inputs a country, and receives a labeled plot of cumulative confirmed cases in that country.  

```{r plotCases}

plotCases <- function(country){
  
  data <- dailyCases(country)
  
  # Convert date column from character into date class
  data$Date <- as.Date(data$Date)
  
  # Plot the data
  ggplot(data, aes(x = Date, y = Cases)) +
    geom_col() +
    ggtitle(paste("Cumulative Cases by Date in ", country, sep = "")) +
    xlab("Date") + ylab("Cumulative Cases")
}
```

### `casesByDate`

The `casesByDate` function interacts with the `By Country Live` endpoint, using the user's choice of country, start date, and end date. It returns a data frame with daily cumulative confirmed case counts, as well as the country's name, abbreviation, and location. 

```{r}
# The user inputs a country or 2-letter abbreviation, 
# and start/end dates in the format YYYY-MM-DD 

casesByDate <- function(country, startDate, endDate){
  
  ###
  # This function returns a data frame with data on number of cumulative confirmed Covid cases between selected dates in selected country. 
  ###
  
  # find the "slug" based on the country the user selected
  slug <- getSlug(country)
  
  # Get the country data from the Day One Live endpoint.
  output <- fromJSON(paste(
    "https://api.covid19api.com/dayone/country/", slug, "/status/confirmed/live?from=", startDate, "T00:00:00Z&to=", endDate, "T00:00:00Z", sep = "")
  )
  
  # If country is in the CountryCode column, subset output for just that row.
  if (country %in% output$CountryCode){
    output <- output %>%
      filter(CountryCode == country)
  }
  # If country is in the Country column, subset output for just that row.
  else if (country %in% output$Country){
    output <- output %>%
      filter(Country == country)
  }
  # Otherwise, throw an informative error.
  else {
    message <- paste("ERROR: Argument for country was not found in either",
                     "the Country or CountryCode columns. Try ('all') to",
                     "find the country you're looking for.")
    stop(message)
  }
  
  # Return the output data frame.
  return(output)
}
```


### `typesByCountry`

The `typesByCountry` function interacts with the `Live By Country and Status` endpoint. This function returns a data frame with data on number of cumulative confirmed Covid cases, deaths, recoveries, and active cases in the selected country over time.  


```{r}

typesByCountry <- function(country){
  
  # find the "slug" based on the country the user selected
  slug <- getSlug(country)
  
  # Get the country data from the Day One Live endpoint.
  output <- fromJSON(paste(
    "https://api.covid19api.com/dayone/country/", slug, "/status/confirmed", sep = "")
  )
  
  # If country is in the CountryCode column, subset output for just that row.
  if (country %in% output$CountryCode){
    output <- output %>%
      filter(CountryCode == country)
  }
  # If country is in the Country column, subset output for just that row.
  else if (country %in% output$Country){
    output <- output %>%
      filter(Country == country)
  }
  # Otherwise, throw an informative error.
  else {
    message <- paste("ERROR: Argument for country was not found in either",
                     "the Country or CountryCode columns. Try ('all') to",
                     "find the country you're looking for.")
    stop(message)
  }
  
  # Return the output data frame.
  return(output)
}
```


`newCount`

After looking through the data while making the functions above, I knew I wanted to calculate the daily number of *new* cases, instead of just looking at cumulative case counts for a country. To get new cases for today, for example one just needs to subtract yesterday's cumulative case count from today's cumulative case count.  
For the `newCount` function, we interact with the `Live By Country and Status After Date` endpoint. The user enters a country of interest and a start date. 
The function will output a data frame for that country with the number of new cases of each type (Confirmed, Deaths, Recovered, Active), each day. 

```{r newCount}
# The user inputs a country's name or 2-letter abbreviation, 
# and start dates in the format "YYYY-MM-DD" 

newCount <- function(country, startDate){

    # find the "slug" based on the country the user selected
  slug <- getSlug(country)
  
  # save the day before so we can do our subtraction to get New cases
  # using the cumulative numbers
  # Had to actually subtract 2 to get data from the day before
  dayBefore <- as.Date(startDate) -2
  
  # Get the country data from the Live By Country And Status After Date endpoint
  output <- fromJSON(paste(
    "https://api.covid19api.com/live/country/", slug, "/status/confirmed/date/", dayBefore, "T13:13:30Z", sep = "")
  )

  # Convert the date column to date class
  output$Date <- as.Date(output$Date)
  
  # Need to sort by province and then date
  # but only if the selected country lists provinces (or states)
  if (!all(is.na(output$Province) | output$Province == "")) {
    output <- output[order(output$Province),]
  }
  
  # needs some work still in order to properly handle countries w/provinces
  
  # Add columns 
  # for new confirmed
  output$newConfirmed[1] <- 0
  output$newConfirmed[2:length(output$Confirmed)] <- diff(output$Confirmed[1:length(output$Confirmed)], lag = 1)
  
  # new deaths column
  output$newDeaths[1] <- 0
  output$newDeaths[2:length(output$Deaths)] <- diff(output$Deaths[1:length(output$Deaths)], lag = 1)  
  
  # new recovered
  output$newRecovered[1] <- 0
  output$newRecovered[2:length(output$Recovered)] <- diff(output$Recovered[1:length(output$Recovered)], lag = 1)    
  
  # new active cases
  output$newActive[1] <- 0
  output$newActive[2:length(output$Active)] <- diff(output$Active[1:length(output$Active)], lag = 1)  
  
  # Delete the first observation
  # It was only returned initially so we could subtract it to get the new numbers that day
  output <- output[-1]
  
  # Return the output data frame.
  return(output)
}
```


### `getAllCovidData`

Finally, I created a function to get all the COVID-19 data from the API and return a dataframe to the user. This function interacts through the `All Data` endpoint, returning 10MB of data, so should be used infrequently.  

```{r getAllCovidData}
getAllCovidData <- function(){

  # Get the data from the All Data endpoint.
  output <- fromJSON("https://api.covid19api.com/all")
  
  # Return the output data frame.
  return(output)
}
```


## Data Exploration    



- You should pull data from at least two endpoints (possibly combining them into one)  
- You should create one (or more) relevant new variable that is a function of the variables from a data set you use  
- You should create some contingency tables  
- You should create numerical summaries for some quantitative variables at each setting of some of your categorical variables  
- You should create at least five plots utilizing coloring, grouping, etc. All plots should have nice labels and titles.  
- You should have at least one bar plot, one histogram, one box plot, and one scatter plot  





